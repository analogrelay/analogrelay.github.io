---
layout: post
title: "Compiler Project - Part 4: ASTs and switching to MGrammar"
description: ""
category:
tags: []
permalink: /blog/2009/2/18/compiler-project-part-4-asts-and-switching-to-mgrammar.html
---
<p>Here's part 4 of my infinite part series on developing a compiler from scratch.&#160; See all the posts <a href="/ct.ashx?id=cbb29a9a-f33f-45e9-8836-47c73a0fd1a0&amp;url=http%3a%2f%2fblog.andrewnurse.net%2fCategoryView%2ccategory%2cCompiler%252BProject.aspx">here</a>.</p>  <p>I've decided to change things up a bit on the compiler project.&#160; Instead of writing the tokenizer and parser from scratch, I'm going to check out a new language that's part of Microsoft's <a href="http://msdn.microsoft.com/en-us/library/cc709420.aspx" target="_blank">"Oslo"?</a> Project.&#160; Oslo includes a language called M, which is primarily designed for developing data models.&#160; M is actually three languages, MGraph, MSchema and MGrammar.&#160; MGraph is a language for defining abstract graphs, for example:</p>  <pre class="m" name="code">Universities {<br/>    Canada {<br/>        BritishColumbia {<br/>            SFU { <br/>                Name { &quot;Simon Fraser University&quot; }, <br/>                Location { &quot;Burnaby, BC&quot; } <br/>            },<br/>            UBC { <br/>                Name { &quot;University of British Columbia&quot; }, <br/>                Location { &quot;Vancouver, BC&quot; } <br/>            }<br/>        }<br/>    }<br/>}</pre><br/><br/><p>MSchema is a language for defining the schema for these graphs, for example</p><br/><br/><pre class="m" name="code">module Universities {<br/>    type University {<br/>        Name : Text#100,<br/>        Location : Text#100<br/>    }<br/>}</pre><br/><br/><p>Finally, MGrammar is a language for defining custom Domain-Specific Languages (DSLs) which map to MGraph graphs. This is the language that is most useful to this project. After all, a general-purpose programming language is just a DSL where the &quot;Domain&quot; is very broad :). So, I've spent a few hours this week whipping up an MGrammar grammar for Duh, and the results are promising.&#160; I'll be posting some details on that in the next post, but first we need to explore a key concept in compilers, Abstract Syntax Trees.</p><br/><br/><p>The end goal of the tokenization and parsing phases of a compiler is to produce an Abstract Syntax Tree (or AST) representing the source code.&#160; This is probably best illustrated by an example, so consider this expression:</p><br/><br/><pre>5+6</pre><br/><br/><p>This is an addition operation, using 5 and 6 as the arguments, which we represent in an AST like this (using the MGraph syntax above):</p><br/><br/><pre>Add { 5, 6 }</pre><br/><br/><p>Similarly, more complex expressions can be translated to trees:</p><br/><br/><pre>5+6*(3+4)</pre><br/><br/><p>Becomes:</p><br/><br/><pre>Add { 5, Multiply { 6, Add { 3, 4 } } }</pre><br/><br/><p>Which represents the following instructions:</p><br/><br/><ul><br/>  <li>Add 3 and 4 </li><br/><br/>  <li>Multiply that result by 6 </li><br/><br/>  <li>Add 5 to that result </li><br/></ul><br/><br/><p>Essentially, we are building up the expression from the bottom of the tree up.&#160; This makes it much easier to convert the expression into code.</p><br/><br/><p>I'll post the MGrammar file for the language when I finish it up in a day or so, then its on to writing the code to do the parsing.</p>
