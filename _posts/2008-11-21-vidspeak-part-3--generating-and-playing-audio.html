---
disqus_old: true
layout: post
title: "VidSpeak Part 3 - Generating and Playing Audio"
description: ""
category:
tags: []
permalink: /blog/2008/11/21/vidspeak-part-3-generating-and-playing-audio.html
---
<p>This is part 3 of my VidSpeak series, where I show off an app I wrote for my multimedia course.&nbsp; <a href="/2008/10/30/VidSpeakPart2BitmapManipulation.aspx">Check out part 2</a>.</p>  <p><strong>5. Generate the Sound</strong></p>  <p>Alright, so this is the complex part :).&nbsp; For the assignment, we were instructed to convert each column of the quantized grayscale 64x64 frame to a chord of sound.&nbsp; We were asked to do this by assigning a frequency to each row of the image (the middle row being 440Hz or "A440", which is the "A" above middle "C" on a piano).&nbsp; Then the "brightness" of the pixel at that row is the intesity of that frequency in the chord.&nbsp; So, if a pixel was black, that frequency was not part of the chord, and if it was white, that frequency was part of the chord (at 100% intensity). </p>  <p>Sound is generated using a process called <a href="http://en.wikipedia.org/wiki/Frequency_Modulation">Frequency Modulation</a> (or "<a href="http://interngame.com/synchronetics/page.php?id=groan&amp;sol=1">FREAK WHEN SEE MOD YOU LATE SHUN</a>" as I like to call it (inside joke for MS interns who did The Microsoft Intern Game :P)).&nbsp; Essentially what we are going to do is create sine waves of each frequency we want to play, scale them by the intensity value, and then add them together to create a new sine wave, representing the whole chord.&nbsp; This process is done with this code </p><br/><br/><pre name="code" class="csharp"><br/>uint* data = (uint*) Marshal.AllocHGlobal(SamplesPerColumn * Marshal.SizeOf(typeof (uint)));<br/>for (int sample = 0; sample < SamplesPerColumn; sample++) {<br/>    double signal = 0.0f;<br/>    for (int col = 0; col < width; col++) {<br/>        PixelData* cell = row0 + col;<br/>        double intensity = cell->Red / (double) (_quantizationLevels - 1);<br/>        signal += (intensity * Math.Sin(2.0f * Math.PI * FrequencyTable[col] * TimeTable[sample]));<br/>    }<br/>    signal = (uint.MaxValue / 2) * (signal + 1);<br/>    *(data + sample) = (uint) signal;<br/>}<br/></pre><br/><br/>  <p>Because sound is represented digitally in computers, we can't send the sine wave itself, we have to take discrete samples of it that we will send to the sound card.&nbsp; In this case, I'm taking 500 samples for each column (SamplesPerColumn = 500).&nbsp; Elsewhere in my code I informed the sound card that I would be generating sound at 8000Hz (or 8000 samples per second), meaning that 500 samples will produce 0.0625seconds of audio. </p>  <p>For each sample I'm going to generate, I iterate across the columns (remember, I rotated the image in step 1 so that each row of the image now represents a column of the original frame).&nbsp; Then I generate a sample of the sine wave for that frequency and multiply it by the value at the pixel (as a float, where 15 is 1.0 and 0 is 0.0) (that's the line that starts "signal +=".&nbsp; Once I've added up all the samples for the chord, I convert the float into an unsigned integer where (uint.MaxValue / 2) represents 0 and store in the (unmanaged) buffer I'm building. </p>  <p>From there, I just send that unmanaged buffer 'data' to the sound card using a helper class I created to wrap the waveOut API: </p>  <p>SoundDevice.WriteAudioBlock(new IntPtr(data), (uint)SamplesPerColumn);</p>  <p>The helper class basically wraps a low-level Win32 API called "waveOut"?.&nbsp; It's not as powerful as using DirectX or some other high-level API, but it gets the job done :).&nbsp; The code for this helper is in the SoundDevice class in my code. Remember, all the code is posted in my <a href="/2008/10/21/VidSpeakPart1ExtractingFramesFromVideoInC.aspx">Part 1 post.</a></p>  <p>That's it for VidSpeak.&nbsp; I'm going to be posting more code from my other school projects soon, but I have to finish them first :P.</p>
