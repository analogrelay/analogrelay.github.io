---
layout: post
title: "Introducing Razor - A New View Engine for ASP.Net"
description: ""
category:
tags: []
permalink: /blog/2010/7/3/introducing-razor-a-new-view-engine-for-aspnet.html
---
<p>UPDATE: Fixed broken examples (I hope :)).</p>  <p>Earlier this morning, <a href="http://weblogs.asp.net/scottgu">Scott Guthrie</a> <a href="http://weblogs.asp.net/scottgu/archive/2010/07/02/introducing-razor.aspx">blogged about a new View Engine we're developing for ASP.Net</a>.&#160; As many of my readers know, I joined the ASP.Net team back in October in 2009, and I'm really excited to finally be able to share what I have been working on for the past 8 months.&#160; When I joined Microsoft, I was shown some early prototypes for this new syntax and over the course of the next 8 months, we developed it into the Beta we're going to be releasing very soon.</p>  <p>Writing the parser for Razor has essentially been my job for the last 8 months, so I'd like to describe a little about some of the design ideas that went in to it as well as some of the interesting ways we implemented things.&#160; This is the first in a few blog posts I'll do about the Razor syntax as well as the Parser design.</p>  <p>Razor syntax is designed around one primary goal: Make code and markup flow together with as little interference from control characters as possible.&#160; For example, let's take the following ASPX:</p><pre class="brush: csharp">&lt;ul&gt;
    &lt;% foreach(var p in Model.Products) { %&gt;
    &lt;li&gt;&lt;%= p.Name %&gt; ($&lt;%= p.Price %&gt;)&lt;/li&gt;
    &lt;% } %&gt;
&lt;/ul&gt;</pre><p>Now, let's boil it down to the parts that we actually care about, removing all of the extra ASPX control characters:</p><pre class="brush: csharp">&lt;ul&gt;
    foreach(var p in Model.Products) {
    &lt;li&gt;p.Name ($p.Price)&lt;/li&gt;
    }
&lt;/ul&gt;</pre><p>Obviously there isn't enough data here to unambiguously determine what's code and what's markup. When we were designing Razor, we started from here and added as little as we could to make it absolutely clear what is code and what is markup. We wanted Razor pages to be Code+Markup, with a little extra stuff as possible. We even used that goal as inspiration for the file extension for C# and VB Razor pages: <strong>cshtml</strong> and <strong>vbhtml</strong>. </p><p>So, using the C# Razor syntax, the above example becomes:</p><pre class="brush: csharp">&lt;ul&gt;
    @foreach(var p in Model.Products) {
    &lt;li&gt;@p.Name ($@p.Price)&lt;/li&gt;
    }
&lt;/ul&gt;</pre><p>If you ask me, that's pretty darn close to the previous example. Razor takes advantage of a deep knowledge of C# (or VB) and HTML syntaxes to infer a lot about what you intended to write. Let's take this sample and break it down chunk by chunk to see how Razor parses this document.</p><pre class="brush: csharp">&lt;ul&gt;</pre><p>When Razor starts parsing a document anything goes until we see an &quot;@&quot;. So this line just gets classified as Markup and we move on to the next</p><pre class="brush: csharp">@foreach(var p in Model.Products) {</pre><p>Here's where things get interesting. Now, Razor has found an &quot;@&quot;. The &quot;@&quot; character is the magic character in Razor. One character, not 5 "&lt;%=%&gt;", and we let the parser figure out the rest. If you skip ahead a bit, you'll notice that there's nothing that indicates the end of the block of code (like the &quot;%&gt;&quot; sequence in ASPX). Rather than having it's own syntax for delimiting code blocks, Razor tries to add as little as possible and just uses the syntax of the underlying language to determine when the code block is finished. In this case, Razor knows that a C# foreach statement is contained within &quot;{&quot; and &quot;}&quot; characters, so when you reach the end of the foreach block, it will go back to markup</p><pre class="brush: csharp">&lt;li&gt;@p.Name ($@p.Price)&lt;/li&gt;</pre><p>Now, things get even more interesting. Didn't I just say we were in Code until the ending of the foreach? This looks a lot like Markup, and we're still inside the foreach! This is another case where Razor is using the syntax of the underlying language to infer your intent. We know that after the &quot;{&quot; C# is expecting some kind of statement. But, instead of a statement, we see an HTML tag &quot;&lt;li&gt;&quot;, so Razor infers that you intended to switch back to Markup. So we've essentially got a stack of 3 contexts: When we started out we were in Markup, then we saw @foreach so we went to Code, now we've see &lt;li&gt; so were back in Markup. At the closing &lt;/li&gt; tag, we know you've finished the inner Markup block, so we go back to the body of the foreach.</p><pre class="brush: csharp">}</pre><p>Then we see the end of the foreach block, so we go back to the top-level Markup context.</p><pre class="brush: csharp">&lt;/ul&gt;</pre><p>And we continue parsing markup until the next &quot;@&quot;, or the end of the file. You may have noticed I skipped over a bit in the middle of the &lt;li&gt; tag. I'll save the details of that for my next post, but the essential logic is the same: &quot;@&quot; starts code, and we use C# syntax to tell us when that code block is finished.</p><p>It's great to finally be able to share the result of our hard work with everyone. We've worked really hard to try to create a really clean syntax for mixing code and markup and I know I'd love to hear your feedback. Post in the comments on my blog, send me a tweet at &quot;@anurse&quot; or send me email at &quot;andrew AT andrewnurse DOT net&quot;.</p><p>And I know you're all probably eagerly awaiting a chance to try this out. Don't worry, we'll have a public beta soon that you can try out!</p>
