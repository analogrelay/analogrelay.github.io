---
layout: post
title: "VidSpeak Part 2 - Bitmap Manipulation"
description: ""
category:
tags: []
permalink: /blog/2008/10/30/vidspeak-part-2-bitmap-manipulation.html
---
<p>This is part 2 of my VidSpeak series, where I show off an app I wrote for my multimedia course.&nbsp; <a href="/2008/10/21/VidSpeakPart1ExtractingFramesFromVideoInC.aspx">Check out part 1</a>.</p><br/><p>To recap from last time, the problem this assignment is trying to solve is to convert video frames to some kind of audio representation.&nbsp; There are the steps required:</p><br/><ol><br/><li>Extract the next frame from the video <br/></li><li>Scale the frame down to 64x64 pixels <br/></li><li>Make the frame a grayscale image <br/></li><li>"Quantize" the grayscale frame into 4-bit colour <br/></li><li>Convert the frame to sound</li></ol><br/><p>I covered extracting video frames in Part 1, so now we have to manipulate the image to prepare it for rendering as sound.</p><br/><p><strong>2. Scale the frame down to 64x64 pixels</strong></p><br/><p>All the transformation steps (2-4) are performed by "filters" which recieve a System.Drawing.Bitmap and return a transformed one (a filter could also modify the incoming Bitmap and then just return the same object).&nbsp; Scaling is trivial with the "GetThumbnailImage" method on System.Drawing.Image:</p><br/><pre name="code" class="csharp">public Bitmap ProcessImage(Bitmap input) {<br/>    return new Bitmap(input.GetThumbnailImage(TargetWidth, TargetHeight, null, IntPtr.Zero));<br/>}<br/></pre><br/><p><strong>3. Make the frame a grayscale image</strong></p><br/><p>There may be a function in .Net to do this, but as part of the assignment we were provided with a formula to convert RGB images to 255-shade grayscale images so I decided to do this.&nbsp; Now, the Bitmap class provides GetPixel and SetPixel methods, but they aren't really very performant when you need to touch every pixel.&nbsp; Fortunately, the Bitmap class provides a method called "LockPixels" which prevents the Garbage Collector from moving the Bitmap data around in memory.&nbsp; With that, I made a base class for filters that process a Bitmap on a Pixel-by-Pixel basis:</p><br/><br/><pre name="code" class="csharp"><br/>BitmapData data = input.LockBits(new Rectangle(0, 0, input.Width, input.Height), <br/>                                 ImageLockMode.ReadWrite, <br/>                                 PixelFormat.Format24bppRgb);<br/>unsafe {<br/>    for (int col = 0; col &lt; data.Width; col++) {<br/>        for (int row = 0; row &lt; data.Height; row++) {<br/>            PixelData* pixel = (PixelData*)data.Scan0 + col + row * data.Width;<br/>            ProcessPixel(pixel);<br/>        }<br/>    }<br/>}<br/>input.UnlockBits(data);<br/></pre><br/><p>PixelData is a simple 3-byte struct:</p><br/><pre name="code" class="csharp">[StructLayout(LayoutKind.Sequential)]<br/>public struct PixelData {<br/>    public byte Blue;<br/>    public byte Green;<br/>    public byte Red;<br/>}</pre><br/><p>Then, my grayscale image filter just has to implement ProcessPixel</p><br/><br/><pre name="code" class="csharp"><br/>byte convertedValue = (byte) Math.Floor((0.299 * pixel-&gt;Red) + <br/>                                        (0.587 * pixel-&gt;Green) + <br/>                                        (0.114 * pixel-&gt;Blue));<br/>pixel-&gt;Red = convertedValue;<br/>pixel-&gt;Green = convertedValue;<br/>pixel-&gt;Blue = convertedValue;</pre><br/><p>Kinda strange to see the "-&gt;" operator in C#, eh?</p><br/><p>4. "Quantize" the image to 4-bit colour</p><br/><p>Quantization is the process of "compressing a range of values to a single quantum value" (<a href="http://en.wikipedia.org/wiki/Quantization_%28image_processing">http://en.wikipedia.org/wiki/Quantization_(image_processing</a>)).&nbsp; In this case, we are quantizing an 8-bit Grayscale image to a 4-bit Grayscale image.&nbsp; To do this, we take each pixel value, and assign it one of 16 partitions (4-bits can hold values 0 through 15).&nbsp; The following code (in FixedPartitionQuantizationStrategy) does this (note _partitionSize is 16 in this case).</p><br/><pre name="code" class="csharp">public byte Quantize(byte input) {<br/>    return (byte)Math.Floor((double)input / _partitionSize);<br/>}</pre><br/><p>Quantization is done by the QuantizeImageFilter, which uses a similar base class to the Grayscale conversion above.&nbsp; Then, an IQuantizationStrategy is used to perform the Quantization itself:</p><br/><pre name="code" class="csharp">protected override unsafe void ProcessPixel(PixelData* pixel) {<br/>    pixel-&gt;Red = _strategy.Quantize(pixel-&gt;Red);<br/>    pixel-&gt;Green = _strategy.Quantize(pixel-&gt;Green);<br/>    pixel-&gt;Blue = _strategy.Quantize(pixel-&gt;Blue);<br/>}<br/></pre><br/><p>And thats it! We now have an image that is 64x64 pixels&nbsp;in 4-bit Grayscale.&nbsp; Next we have to render it out to sound.&nbsp; Stay tuned for Part 3 for that!</p>
