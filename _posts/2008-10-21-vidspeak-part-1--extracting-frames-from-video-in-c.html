---
layout: post
title: "VidSpeak Part 1 - Extracting Frames from Video in C#!"
description: ""
category:
tags: []
permalink: /blog/2008/10/21/vidspeak-part-1-extracting-frames-from-video-in-c.html
---
<p>I know, its been too long since I blogged, but its pretty busy at school right now :). Anyway, I'm taking a course in Multimedia this semester, and as part of that course, I have to write a program to convert frames in a Video to short Audio clips.&nbsp;I thought it might&nbsp;be interesting to examine how that is done, in C#.&nbsp; So, over the course of about 3-4 posts, I'll go over the code that I wrote.&nbsp; I've attached the full project to this post, so you can take a look at it right now.&nbsp; The GUI app should work, though I can't guarantee it. All I can give it is "Works on My Machine" seal of approval :)&nbsp;</p><br/><p><img src="http://www.codinghorror.com/blog/images/works-on-my-machine-starburst.png"> </p><br/><p></p><br/><p>Here are the steps involved:</p><br/><ol><br/><li>Extract the next frame from the video <br/></li><li>Scale the frame down to 64x64 pixels <br/></li><li>Make the frame a grayscale image <br/></li><li>"Quantize" the grayscale frame into 4-bit colour <br/></li><li>Convert the frame to sound</li></ol><br/><h5>The Code</h5><br/><p>The Code is a Visual Studio 2008 solution, written for .Net 3.5.&nbsp; It uses unsafe code for image processing and sound generation, so you can't run it without full trust (i.e. you can't run it off of a network share).</p><br/><h5>1. Extract the next frame from the video</h5><br/><p>I used a "Pipeline" (<a href="http://en.wikipedia.org/wiki/Pipeline_%28software%29">http://en.wikipedia.org/wiki/Pipeline_(software)</a>) architecture, so this phase is handled by a component I call a "Frame Source" which is expected to return a new frame when asked (or return null to signal the end of the input). I used the DirectShow COM library "<a href="http://msdn.microsoft.com/en-us/library/ms783323.aspx">DexterLib</a>" to do the extraction. DexterLib contains a class called MediaDet (for MediaDetector) which does most of the work. Here's the code for the function which retrieves a frame at a specified timecode (in seconds).&nbsp; </p><br/><p>FYI: "_detector" is an instance of DexterLib.MediaDetClass() ("_detector" is of type IMediaDet), "_streamLength" is the length of of the video stream in seconds, "_bufferHandle" is an IntPtr referring to an unmanaged buffer (allocated with Marshal.AllocHGlobal) to hold the bitmap, and "_bufferSize"/"_frameSize" are the size of the buffer and the size of each video frame (respectively)</p><br/><pre name="code" class="csharp">// WARNING: This method will destroy the bitmap retrieved in a previous call to this method<br/>public Bitmap GetFrameAtTime(double timeCode) {<br/>    // Get the bitmap at this time<br/>    Bitmap frame = null;<br/>    unsafe {<br/>        byte* bufferPointer = (byte*)_bufferHandle;<br/>        _detector.GetBitmapBits(timeCode, <br/>                                ref _bufferSize, <br/>                                ref *bufferPointer, <br/>                                _frameSize.Width, <br/>                                _frameSize.Height);<br/>        frame = new Bitmap(_frameSize.Width, // Width<br/>                           _frameSize.Height, // Heigth<br/>                           _frameSize.Width * 3, // Stride<br/>                           PixelFormat.Format24bppRgb, // Pixel Format<br/>                           new IntPtr(bufferPointer + <br/>                                      Marshal.SizeOf(typeof(BITMAPINFOHEADER)))); // Start of Buffer<br/>    }<br/><br/>    return frame;<br/>}</pre><br/><p>(Note: If you look at the actualy code, you will notice I snipped out some stuff from the beginning of this function to display it on the blog.&nbsp;The missing code just handles an (experimental) feature I added to allow me to start at any location in the video, rather than always starting at the beginning)</p><br/><p>After loading the frame, I have to flip it, because Dexter loads the frame upside-down, fortunately the System.Drawing.Image class provides a RotateFlip method to do just that! I also rotate it 90 degrees clock-wise, so that each row of the transformed image maps to a column of the frame. This makes step 5 easier, since Bitmaps are stored in "row-major" order (<a href="http://en.wikipedia.org/wiki/Row-major_order">http://en.wikipedia.org/wiki/Row-major_order</a>).</p><br/><p>To use the Frame Source, all my program has to do is call GetFrameAtTime method passing in a timecode (in seconds).&nbsp; This is handled in the FrameProcessor by the GetNextFrame method</p><br/><pre name="code" class="csharp">_source.GetFrameAtTime((DateTime.Now - _startTime).TotalSeconds)</pre><br/><p>Rather than going frame-by-frame, I'm extracting the next frame by time.&nbsp; So, if it takes 4 seconds to process a frame, the next frame I take is approximately 4 seconds after the frame I just processed.</p><br/><p>Here's the code: <a href="http://dl.dropbox.com/u/17594081/BlogContent/03082011-Import/VidSpeak.zip">VidSpeak.zip (267.21 KB)</a></p>
