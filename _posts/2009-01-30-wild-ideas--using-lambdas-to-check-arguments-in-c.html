---
disqus_old: true
layout: post
title: "Wild Ideas - Using lambdas to check arguments in C#"
description: ""
category:
tags: []
permalink: /blog/2009/1/30/wild-ideas-using-lambdas-to-check-arguments-in-c.html
---
<p>One of the most common checks I do is a simple null check on arguments being passed in to the methods I write.&nbsp; I usually create a static class called "Arg" with the following methods (to help out):</p>  <pre class="csharp" name="code">public static class Arg {<br/>    public static void NotNull(object value, string paramName) {<br/>        if (value == null) {<br/>            throw new ArgumentNullException(paramName);<br/>        }<br/>    }<br/>    public static void NotNullOrEmpty(string value, string paramName) {<br/>        if (String.IsNullOrEmpty(value)) {<br/>            // ED: Error_StringArgumentNullOrEmpty is a key in my Visual Studio<br/>            //  project's default string resources file (Properties/Resources.resx)<br/>            throw new ArgumentException(<br/>                String.Format(CultureInfo.CurrentCulture, <br/>                              Resources.Error_StringArgumentNullOrEmpty, <br/>                              paramName), <br/>                paramName);<br/>        }<br/>    }<br/>}</pre><p>Then, I can use it like this</p><pre class="csharp" name="code">public void Foo(string arg, object reallyLongArgumentName) {<br/>    Arg.NotNullOrEmpty(arg, "arg");<br/>    Arg.NotNull(reallyLongArgumentName, "reallyLongArgumentName");<br/>}</pre><p>I was recently playing with <a href="http://msdn.microsoft.com/en-us/library/bb397687.aspx" target="_blank">lambda expressions</a> in C# and thought of a way to make this a little cooler.&nbsp; The result is, I can rewrite the lines above like this:</p><pre class="csharp" name="code">public void Foo(string arg, object reallyLongArgumentName) {<br/>    Arg.NotNullOrEmpty(() =&gt; arg);<br/>    Arg.NotNull(() =&gt; reallyLongArgumentName);<br/>}</pre><p>The first obvious advantage is that for longer argument names, its more concise.&nbsp; The second, is that I no longer have to worry about updating the strings representing the parameter names when I rename arguments, the Visual Studio Refactoring engine will take care of it for me.</p><p>Obviously, this is slower than the previous method since I'm diving into the lambda expression at runtime, but its cool.&nbsp; But if I need the performance, I have a little Regular Expression I can run in Visual Studio to convert the lambda calls back to the string versions (and vice-versa)</p><p>How does it work? Well, the core of the code is a static helper in the <code>Arg</code> class</p><pre class="csharp" name="code">private static string GetParameterName&lt;T&gt;(Expression&lt;Func&lt;T&gt;&gt; paramExpr) {<br/>    LambdaExpression lambda = paramExpr as LambdaExpression;<br/>    Debug.Assert(lambda != null);<br/>    MemberExpression paramRef = lambda.Body as MemberExpression;<br/>    Debug.Assert(paramRef != null);<br/>    // Get the parameter name<br/>    string paramName = paramRef.Member.Name;<br/>    return paramName;<br/>}</pre><p>Lines 2-5 dive through the Expression tree to find the <code>MemberExpression</code> that represents the parameter (i.e. "foo" in <code>() =&gt; foo</code>). Then, we pull out the <code>MemberInfo</code> for the parameter and check the name. With that method, the actual checker is easy:</p><pre class="csharp" name="code">public static void NotNull(Expression&lt;Func&lt;object&gt;&gt; paramExpr) {<br/>    string paramName = GetParameterName(paramExpr);<br/>    // Compile the lambda (to get the value)<br/>    Func&lt;object&gt; compiledLambda = paramExpr.Compile();<br/>    <br/>    // Run the contract check<br/>    NotNull(compiledLambda(), paramName);<br/>}</pre><p>Line 2 extracts the parameter name. Line 5 compiles the lambda into an actual function that will return the value of the parameter. Finally, Line 8 uses the value and the parameter name to call my original <code>object/string</code> version. The code for <code>NotNullOrEmpty</code> is nearly identical.</p><p>Anyway, if you're concerned about performance, stick to the overloads which take the parameter name directly. I've attached the code as a TXT file, just rename to C#, change the namespace as appropriate and enjoy</p><a href="https://s3.amazonaws.com/vibrantcode-res/blogcontent/imported/Arg.txt">Arg.txt (3.93 KB)</a>
