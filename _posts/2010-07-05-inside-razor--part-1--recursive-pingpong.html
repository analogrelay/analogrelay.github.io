---
disqus_old: true
layout: post
title: "Inside Razor - Part 1 - Recursive Ping-Pong"
description: ""
category:
tags: []
permalink: /blog/2010/7/5/inside-razor-part-1-recursive-ping-pong.html
---
<p>This is the first of my blog posts about the parser for the new <a href="http://weblogs.asp.net/scottgu/archive/2010/07/02/introducing-razor.aspx">ASP.Net Razor</a> syntax.&nbsp; We've been working on this parser for a while now, and I want to share some of how it works with my readers!</p>  <p>The Razor parser is very different from the existing ASPX parser.&nbsp; In fact, the ASPX parser is implemented almost entirely with Regular Expressions, because it is a very simple language to parse.&nbsp; The Razor parser is actually separated into three components: 1) A Markup parser which has a basic understanding of HTML syntax, 2) A Code parser which has a basic understanding of either C# or VB and 3) A central orchestrator which understands how the two mix together.&nbsp; Note that when I say "basic understanding" I mean basic, we're not talking about full-fledged C# and HTML parsers here.&nbsp; I've joked with people on the team that we should call them "Markup Understander" or "Code Comprehender" instead :).</p>  <p>So the Razor parser has three "actors"?: The Core Parser, the Markup Parser and the Code Parser.&nbsp; All three work together to parse a Razor document.&nbsp; Now, let's take a Razor file and do a full summary of the parsing procedure using these actors.&nbsp; We'll use the sample that I used last time:</p>  <br/><pre class="csharp" name="code"><br/>&lt;ul&gt;<br/>    @foreach(var p in Model.Products) {<br/>    &lt;li&gt;@p.Name ($@p.Price)&lt;/li&gt;<br/>    }<br/>&lt;/ul&gt;<br/></pre><br/><br/><p>Ok, now we start at the top. The Razor parser is essentially in one of three states at any time during the parsing: Parsing a Markup Document, Parsing a Markup Block or Parsing a Code Block.&nbsp; The first two are handled by the Markup Parser, and the last is handled by the Code Parser.&nbsp; So, when the Core Parser is fired up for the first time, it calls into the Markup Parser and asks it to parse a Markup Document and return the result.&nbsp; Now the parser is in the Markup Document state.&nbsp; In this state, it simply scans forward to the next "@" character, it doesn't care about tags or other HTML concepts, just "@"?.&nbsp; When it reaches an "@"?, it makes a decision: "Is this a switch to code, or is it an email address?"?&nbsp; This decision is basically done by looking just before and just after the "@" to see if they are valid email characters.&nbsp; This is the default convention, but there are escape sequences to force it to be treated as a switch to code.</p><br/><br/><p>In this case, when we see our first "@"?, it is preceded by whitespace, which is not valid in an email address.&nbsp; So, we now know we are switching to code.&nbsp; The Markup Parser calls into the Code Parser and asks it to parse a Code Block.&nbsp; A Block, in terms of the Razor Parser, is basically a single chunk of Code or Markup with a clear start and end sequence.&nbsp; So, the 'foreach' statement here is an example of a Code Block.&nbsp; It starts at the "f" character and ends at the "}" character.&nbsp; The Code Parser knows enough about C# to know this, so it starts parsing the code.&nbsp; The Code Parser does some very simple tracking of C# statements, so when it gets to the "&lt;li&gt;" it knows it's at the start of a C# statement.&nbsp; "&lt;li&gt;" is not something you can put at the start of a C# statement, so the Code Parser knows that this is the start of nested Markup Block.&nbsp; So, it calls back into the Markup Parser, to have it parse a block of HTML.&nbsp; This creates a sort of <strong>recursive ping-pong game</strong> between the Code and Markup parsers.&nbsp; We start in Markup, then call into Code, then call into Markup and so on before finally returning back up this whole chain.&nbsp; At the moment, the call stack in the parser looks something like this:</p><br/><br/><ul><br/>  <li>HtmlMarkupParser.ParseDocument() <br/>    <ul><br/>      <li>CSharpCodeParser.ParseBlock() <br/>        <ul><br/>          <li>HtmlMarkupParser.ParseBlock() </li><br/>        </ul><br/>      </li><br/>    </ul><br/>  </li><br/></ul><br/><br/><p>(Obviously, I am leaving out a lot of helper methods :)).</p><br/><br/><p>This highlights a fundamental difference between ASPX and Razor.&nbsp; In an ASPX file, you can think of Code and Markup as two parallel streams.&nbsp; You write some Markup, then you jump over and write some code, then you jump back and write some Markup, and so on.&nbsp; A Razor file is like a tree.&nbsp; You write some Markup, and then put some Code <strong>inside</strong> that Markup, then put some Markup <strong>inside</strong> that Code, and so on.</p><br/><br/><p>So, we've just called into the Markup Parser to parse a block of Markup, this block starts at "&lt;li&gt;" and ends at the matching "&lt;/li&gt;"?.&nbsp; Until that matching "&lt;/li&gt;"?, we won't consider the Markup Block finished.&nbsp; So even if you had a "}" somewhere inside the "&lt;li&gt;" it wouldn't terminate the "foreach"?, because we haven't come far enough up the stack yet.</p><br/><br/><p>While parsing the "&lt;li&gt;"?, the Markup Parser sees more "@" characters, which means even more calls into the Code Parser. And so the call stack grows:</p><br/><br/><ul><br/>  <li>HtmlMarkupParser.ParseDocument() <br/>    <ul><br/>      <li>CSharpCodeParser.ParseBlock() <br/>        <ul><br/>          <li>HtmlMarkupParser.ParseBlock() <br/>            <ul><br/>              <li>CSharpCodeParser.ParseBlock() </li><br/>            </ul><br/>          </li><br/>        </ul><br/>      </li><br/>    </ul><br/>  </li><br/></ul><br/><br/><p>I'll go into detail on how these blocks are terminated later, because it is a little complicated, but eventually we finish these code blocks and we're back in the "&lt;li&gt;" block.&nbsp; Then, we see "&lt;/li&gt;" so we finish that block and pop back up to the "foreach" block.&nbsp; The "}" terminates that block, so we back up to the top of our stack again: the Markup Document.&nbsp; Then we read until the end of the file, not finding anymore "@" characters.&nbsp; And we're done!&nbsp; We've parsed the entire file!</p><br/><br/><p>I hope that's made the general structure of the parsing algorithm somewhat more clear.&nbsp; The key take-away here is to avoid thinking of Code and Markup as separate streams and think of them as constructs you nest inside each other.&nbsp; Our next topic will be Implicit Expressions, which is the logic that allows us to detect what parts of "@p.Name ($@p.Price)" are code, and what are markup.&nbsp; I'll give you a hint, we took some inspiration from PowerShell here ;).</p><br/><br/><p>Please post any questions or comments in the comments section or email me at "andrew AT andrewnurse DOT net"?!</p>
