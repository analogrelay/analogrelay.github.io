---
disqus_old: true
layout: post
title: "Compiler from Scratch - Part 2: Normalizing Newlines"
description: ""
category:
tags: []
permalink: /blog/2009/1/25/compiler-from-scratch-part-2-normalizing-newlines.html
---
<p>Well, this is a good sign, I'm posting part 2 :). As I said in <a href="/2009/01/19/WritingACompilerFromScratchNdashPart1.aspx" target="_blank">Part 1</a>, there are no promises here. This series may not go anywhere, I may have to drop it due to my other commitments (school, work, etc.).</p>  <p>In the next few posts, I'm going to talk about the Tokenization phase of the compiler. Before I go into too much detail on that though, I want to talk about newlines.</p>  <p>In Windows, a new line in a text file is indicated by a pair of characters: A Carriage Return (commonly referred to as "\r", as that is the C/C++ string escape sequence for it) followed by a Line Feed ("\?n"?). However, in Unix-based operating systems, a new line is often indicated by a Line Feed character alone. To add even more confusion, the Mac OS uses a Carriage Return character alone. </p>  <p>A compiler needs to track line numbers accurately, in order to report errors, so we need be extra careful around newlines. We could simply use the current operating system's default newline characters, but that makes it difficult for multi-platform development. Instead, we'll normalize the newlines so that all three different types are properly understood by our compiler.</p>  <p>To do this, I've written a "Decorator" class which inherits from the abstract <code>TextReader</code> class provided in the .Net framework. This "Newline Normalizing" decorator wraps an existing <code>TextReader</code> and does all the work of normalizing new line characters TextReader provides two methods that need to be implemented, <code>Read</code> and <code>Peek</code>. <code>Read</code> returns the current character from the text and moves the reader one character forwards (so that the next call to Read will return the next character). <code>Peek</code> also returns the current character from the text but <strong>does not</strong> move the reader forward. The "Newline Normalizing" reader implements these two methods using the following code</p>  <pre class="csharp" name="code">public override int Peek() {<br/>    // Get the next character<br/>    int i = Adaptee.Peek();<br/>    <br/>    // If the character is a 'r' newline, just return 'n'.  <br/>    // Unlike Read, we aren't going to read ahead to check for rn<br/>    // because that will happen when the user calls Read()<br/>    if (i == (int)'r') {<br/>        i =  (int)'n';<br/>    }<br/>    return i;<br/>}<br/>public override int Read() {<br/>    // Get the next character<br/>    int i = Adaptee.Read();<br/>    // If the character is a 'r' newline, we're going to normalize it to 'n'<br/>    // However, if the newline is 'rn', we need to return it as one character, so<br/>    // we check ahead for that<br/>    if (i == (int)'r') {<br/>        if (Adaptee.Peek() == (int)'n') {<br/>            Adaptee.Read(); // Skip the 'n'<br/>        }<br/>        i = (int)'n';<br/>    }<br/>    return i;<br/>}</pre><p>Essentially, if the character we read from the source (the "Adaptee" as I call it) is a '\n', we just pass it along. If the character is a '\r', we are going to return '\n', but first we first check to see if it is immediately followed by a '\n'. If it is, we skip the extra character. The result is that no matter which newline sequence is used, this <code>TextReader</code> will return it as a single '\n' character.</p><p>Next post, I'll start talking about the Tokenization process.</p>
