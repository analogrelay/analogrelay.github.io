---
disqus_old: true
layout: post
title: "Compiler from Scratch - Part 2: Normalizing Newlines"
description: ""
category:
tags: []
permalink: /blog/2009/1/25/compiler-from-scratch-part-2-normalizing-newlines.html
---
<p>Well, this is a good sign, I'm posting part 2 :).&#160; As I said in <a href="/2009/01/19/WritingACompilerFromScratchNdashPart1.aspx" target="_blank">Part 1</a>, there are no promises here.&#160; This series may not go anywhere, I may have to drop it due to my other commitments (school, work, etc.).</p>  <p>In the next few posts, I'm going to talk about the Tokenization phase of the compiler.&#160; Before I go into too much detail on that though, I want to talk about newlines.</p>  <p>In Windows, a new line in a text file is indicated by a pair of characters: A Carriage Return (commonly referred to as "\r", as that is the C/C++ string escape sequence for it) followed by a Line Feed ("\?n"?).&#160; However, in Unix-based operating systems, a new line is often indicated by a Line Feed character alone.&#160; To add even more confusion, the Mac OS uses a Carriage Return character alone.&#160; </p>  <p>A compiler needs to track line numbers accurately, in order to report errors, so we need be extra careful around newlines.&#160; We could simply use the current operating system's default newline characters, but that makes it difficult for multi-platform development.&#160; Instead, we'll normalize the newlines so that all three different types are properly understood by our compiler.</p>  <p>To do this, I've written a "Decorator" class which inherits from the abstract <code>TextReader</code> class provided in the .Net framework.&#160; This "Newline Normalizing" decorator wraps an existing <code>TextReader</code> and does all the work of normalizing new line characters&#160; TextReader provides two methods that need to be implemented, <code>Read</code> and <code>Peek</code>.&#160; <code>Read</code> returns the current character from the text and moves the reader one character forwards (so that the next call to Read will return the next character).&#160; <code>Peek</code> also returns the current character from the text but <strong>does not</strong> move the reader forward.&#160; The "Newline Normalizing" reader implements these two methods using the following code</p>  <pre class="csharp" name="code">public override int Peek() {<br/>    // Get the next character<br/>    int i = Adaptee.Peek();<br/>    <br/>    // If the character is a 'r' newline, just return 'n'.  <br/>    // Unlike Read, we aren't going to read ahead to check for rn<br/>    // because that will happen when the user calls Read()<br/>    if (i == (int)'r') {<br/>        i =  (int)'n';<br/>    }<br/><br/>    return i;<br/>}<br/><br/>public override int Read() {<br/>    // Get the next character<br/>    int i = Adaptee.Read();<br/><br/>    // If the character is a 'r' newline, we're going to normalize it to 'n'<br/>    // However, if the newline is 'rn', we need to return it as one character, so<br/>    // we check ahead for that<br/>    if (i == (int)'r') {<br/>        if (Adaptee.Peek() == (int)'n') {<br/>            Adaptee.Read(); // Skip the 'n'<br/>        }<br/>        i = (int)'n';<br/>    }<br/><br/>    return i;<br/>}</pre><br/><br/><p>Essentially, if the character we read from the source (the "Adaptee" as I call it) is a '\n', we just pass it along.&#160; If the character is a '\r', we are going to return '\n', but first we first check to see if it is immediately followed by a '\n'.&#160; If it is, we skip the extra character.&#160; The result is that no matter which newline sequence is used, this <code>TextReader</code> will return it as a single '\n' character.</p><br/><br/><p>Next post, I'll start talking about the Tokenization process.</p>
