---
disqus_old: true
layout: post
title: "Argument check gotcha with \"yield\" keyword in C#"
description: ""
category:
tags: []
permalink: /blog/2009/2/2/argument-check-gotcha-with-yield-keyword-in-c.html
---
<p>I recently used the 'yield' keyword in a C# method and ran into a strange issue when trying to verify arguments. I always try to verify the arguments provided to my methods so that I can throw <code>ArgumentException</code> or <code>ArgumentNullException</code> as necessary. However, when you use the 'yield' keyword to create an enumerator in C#, you can run into issues</p>  <p>The 'yield' keyword lets you easily create a method which returns an enumerator (which can then be used in a <code>foreach</code> loop). For example, if I wanted to make a method that took a <code>DirectoryInfo</code> (representing a directory on disk) and returned file names of all the .txt files in it, I would write this:</p>  <pre class="csharp" name="code">public IEnumerable&lt;string&gt; GetTextFiles(DirectoryInfo dir) {<br/>    if (dir == null) {<br/>        throw new ArgumentNullException(&quot;dir&quot;);<br/>    }<br/>    foreach (FileInfo file in dir.GetFiles(&quot;*.txt&quot;)) {<br/>        yield return file.Name;<br/>    }<br/>}</pre><p>However, the C# compiler will do something tricky with this method, because of the 'yield' keyword. It will create a custom implementation of <code>IEnumerable&lt;string&gt;</code> class that uses &quot;magic&quot; (I'm not going to go into detail as to how it works :P) to jump in and out of the code you wrote. Then, it compiles our method to the following (as decompiled with <a href="http://www.red-gate.com/products/reflector/" target="_blank">RedGate's .Net Reflector</a>, a free tool every .Net developer <strong>must</strong> have :D):</p><pre class="csharp" name="code">public IEnumerable&lt;string&gt; GetTextFiles(DirectoryInfo dir)<br/>{<br/>    &lt;GetTextFiles&gt;d__0 d__ = new &lt;GetTextFiles&lt;d__0(-2);<br/>    d__.&lt;&gt;4__this = this;<br/>    d__.&lt;&gt;3__dir = dir;<br/>    return d__;<br/>}</pre><p>Wait a sec, where'd our code go? It looks like it's gone into this <code>&lt;GetTextFiles&gt;d__0</code> class. If you think that name sounds compiler-generated, you're right! It's the custom implementation of <code>IEnumerable&lt;string&gt;</code> that was created by the compiler. Cool, eh? However, there's a side effect here. Where did our argument checking code go? Unless there's something in the <code>&lt;GetTextFiles&gt;d__0</code> constructor, the user could pass <code>null</code> in for the <code>dir</code> parameter and no exception would be thrown! So, let's take a look at the <code>&lt;GetTextFiles&gt;d__0</code> constructor (using Reflector again):</p><pre class="csharp" name="code">[DebuggerHidden]<br/>public &lt;GetTextFiles&gt;d__0(int &lt;&gt;1__state)<br/>{<br/>    this.&lt;&gt;1__state = &lt;&gt;1__state;<br/>    this.&lt;&gt;l__initialThreadId = Thread.CurrentThread.ManagedThreadId;<br/>}</pre><p>Nope, nothing there. If you keep checking around the <code>&lt;GetTextFiles&gt;d__0</code> class, you'll find it in the <code>MoveNext</code> method on that class. That means that instead of checking the argument when you call the method, the argument won't be checked until the first time <code>MoveNext</code> is called (i.e. the first iteration of a foreach loop). If, instead, we wrap the actual "yield" code in it's own method, and call it from our original method (after argument checks), we'll get the desired result:</p><pre>public IEnumerable&lt;string&gt; GetTextFiles(DirectoryInfo dir) {<br/>    if (dir == null) {<br/>        throw new ArgumentNullException(&quot;dir&quot;);<br/>    }<br/>    return InternalGetTextFiles(dir);<br/>}<br/>private IEnumerable&lt;string&gt; InternalGetTextFiles(DirectoryInfor dir) {<br/>    foreach (FileInfo file in dir.GetFiles(&quot;*.txt&quot;)) {<br/>        yield return file.Name;<br/>    }<br/>}</pre><p>Now, the &quot;magic&quot; is occurring in <code>InternalGetTextFiles</code> and <code>GetTextFiles</code> is compiled without modification and our argument checking works just fine.</p>
