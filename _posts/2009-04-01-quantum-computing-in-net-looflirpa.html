---
disqus_old: true
layout: post
title: "Quantum Computing in .Net \"Looflirpa\""
description: ""
category:
tags: []
permalink: /blog/2009/4/1/quantum-computing-in-net-looflirpa.html
---
<p>Microsoft is really taking major strides in terms of improving the programming experience for developers on all current and <strong>future</strong> computing platforms. That's why, earlier today, Microsoft released a beta of the new "System.QuantumEntanglement" library. This library, being considered for integration with .Net 4.1 (which, my sources say, is codenamed "Looflirpa"?), provides features for developers working on quantum computers. I won't go in to too much detail, but this essentially means working in an environment where objects can be in many different states (possibly an infinite number) and where observation may change the state of an object. Microsoft has proposed a few options, but I have some additional ideas.</p>  <h3>Microsoft's Proposal</h3>  <p><a href="http://weblogs.asp.net/leftslipper/" target="_blank">Eilon Lipton</a>, of the ASP.Net MVC team, <a href="http://weblogs.asp.net/leftslipper/archive/2009/04/01/the-string-or-the-cat-a-new-net-framework-library.aspx" target="_blank">is proposing a number of new additions to the .Net BCL in 4.1</a>. The first, is a class called "StringOr&lt;T&gt;" which has the following API:</p>  <pre class="csharp" name="code">namespace System.QuantumEntanglement {<br/>    public class StringOr&lt;TOther&gt; {<br/>        public StringOr(string stringValue, TOther otherValue);<br/>        public string StringValue { get; }<br/>        public TOther OtherValue { get; }<br/>    }<br/>}</pre><p>This class is used to encapsulate a value which may be a string, but may be another value. This is a common user-input scenario, since almost all user input arrives as strings, but will usually be converted to another data type. He also proposes a more general class called "SchrodingOr&lt;TDead, TAlive&gt;"?</p><pre class="csharp" name="code">namespace System.QuantumEntanglement {<br/>    public class SchrodingOr&lt;TDead, TAlive&gt; {<br/>        public SchrodingOr(TDead dead, TAlive alive);<br/>        public TAlive Alive { get; }<br/>        public TDead Dead { get; }<br/>    }<br/>}</pre><p>This generalizes StringOr&lt;T&gt; to support any two types. </p><p>Eilon's not the only one talking about this, <a href="http://www.hanselman.com/blog/NET41PreviewNewBaseClassLibraryBCLExtensionMethodsRFC.aspx" target="_blank">Scott Hanselman</a> (well known Microsoft blogger), and <a href="http://blog.wekeroad.com/blog/cool-extension-methods-for-new-stringor/" target="_blank">Rob Conery</a> (Author of the .Net Object-Relational Mapper: SubSonic) have also posted on this topic. So I figured I'd add my comments to the blogosphere.</p><p>StringOr and SchrodingOr are great starts, but what if we need to represent objects which may be in 2 states? What about 3 states? Infinite states? That's where my proposals come in. I propose the following additions to Eilon's library:</p><h3>Generalizing SchrodingOr</h3><p>The first is SchrodingOr&lt;T1, T2, T3, T4, T5, ... , T<em>n</em>&gt; (for infinite <em>n</em>). This allows the developer to represent objects in as many states as they want. </p><h3>C# 5.0 Compiler Support</h3><p>I'm also proposing the following language syntax to help developers work with these types. Similar to the way the C# compiler converts "int?" to "Nullable&lt;int&gt;" (which would now be replaced with "SchrodingOr&lt;int, Void&gt;" as it more accurately represents the concept of a type which may or may not have a value), the new syntax takes the following:</p><pre class="csharp" name="code">int?string?bool?DateTime? foo = GetUserInput(...);</pre><p>And produces output code which looks like this:</p><pre class="csharp" name="code">SchrodingOr&lt;int, DateTime, bool, string&gt; foo = GetUserInput(...);</pre><p>Then, we can defer observation until a later time, using the AsA&lt;T&gt;/AsAn&lt;T&gt; method (since Eilon's Alive and Dead properties no longer work in an infinite state environment). If we just want to observe the type and then make a decision, we can use IsA&lt;T&gt;/IsAn&lt;T&gt; methods (of course, both are required, just in case the type starts with a vowel), which returns a boolean indicating if the object is of the type <em>T</em>. For example:</p><pre class="csharp" name="code">if(foo.IsA&lt;string&gt;()) { return foo.AsA&lt;string;&gt;; }</pre><h3>Probabilistic Observation</h3><p>Sometimes, we may want to observe an object only if there is a high probability of it being in the right state, to avoid additional quantum variations. To do this, we can use the CouldBeA&lt;T&gt;/CouldBeA&lt;T&gt; methods. These can, optionally, accept a probability threshold beyond which a object is considered in the right state.</p><h3>Quantum Snapshots</h3><p>Unfortunately, in between a call to IsA/An/CouldBeA/An and AsA/An, the state of the object may change. So, we may wish to observe an object and record the state of the object at the time of observation. Since in observing the object we may change its state, our observations must be recorded in "Snapshots"?. The snapshot is an instance of QuantumSnapshotOf&lt;TSchrodingOr&gt; (where <em>TSchrodingOr</em> must be one of the SchrodingOr&lt;T1, ..., T<em>n</em>&gt; types), and has a property &quot;Taken&quot;, which is a DateTimeOffset (after all, we need precise timing here) containing the exact time that the snapshot was taken. </p><p>Here's an example combining Probabilistic Observation and Snapshots:</p><pre class="csharp" name="code">if(foo.CouldBeA&lt;string&gt;()) {<br/>	QuantumSnapshotOf&lt;SchrodingOr&lt;int, string&gt;&gt; snapshot = foo.Observe();<br/>	if(snapshot.Taken.Day == 1 &amp;&amp; snapshot.Taken.Month == 4) {<br/>		throw new UnreliableObservationException(snapshot, &quot;The data is unreliable&quot;);<br/>	}<br/>	return snapshot.AsA&lt;string&gt;();<br/>}</pre><h3>Summary</h3><p>I think this is really interesting, forward-thinking, stuff from Microsoft. Eilon has done some fantastic work getting the ball rolling, and its up to us to give our feedback! Microsoft has created a section on MSDN for discussion on these new features: <a href="http://en.wikipedia.org/wiki/April_Fool%27s_Day" target="_blank">http://msdn.microsoft.com/en-US/QuantumEntanglement/Default.aspx</a></p>
