---
disqus_old: true
layout: post
title: "Mappr: Projecting Geographical Points on the Screen"
description: ""
category:
tags: []
permalink: /blog/2009/1/9/mappr-projecting-geographical-points-on-the-screen.html
---
<p>One of the courses I took last semester (Fall 2008), was "Software Engineering II". In this class, we were required to work in groups to implement a project that the professor specified. We had to go through the whole process, design, implementation, testing (though we could choose any software process model we wanted: Waterfall, XP, Agile, etc.). Our group's project was an application called "Mappr" that would allow users to browse a map. Well, it was a little more than that, but that's all the background required by this post, I'll post more background in future posts.</p>  <p>One of the necessary components in mapping software is called a "Projection". The Earth is round, and Latitude and Longitude co-ordinates are spherical measurements representing points on the Earth. In order to convert those co-ordinates to (x, y) co-ordinates for displaying on a (flat) computer screen, you must <em>project</em> the geographical co-ordinates into screen co-ordinates. One well-known technique for doing this is called the <a href="http://en.wikipedia.org/wiki/Mercator_projection">Mercator Projection</a>.</p>  <p>A quick aside: The Mercator Projection is widely known (in geography circles) for being highly inaccurate. However, it is the projection used by most road maps, atlases, etc., both physical and digital.</p>  <p>In Mappr, projection is handled by a component called a "Projection Strategy"?. A Projection Strategy is a C# class (Mappr was written in C#) with two methods: GeoToScreen and ScreenToGeo.&#160; Here are the signatures of those methods:</p>  <pre class="csharp" name="code">public interface IProjectionStrategy {<br/>    Point GeoToScreen(Point geographicalPoint, int zoomLevel, int tileSize);<br/>    Point ScreenToGeo(Point screenPoint, int zoomLevel, int tileSize);<br/>}</pre><p>The purpose of each method is straight forward: To take in either Geographical (Latitude, Longitude) co-ordinates or Screen (X, Y) co-ordinates, and convert them to the other. In order to do this, we must know the Zoom Level, which is an integer <em>N</em> indicating that there are <em>2<sup>N</sup></em> tiles on the screen. We also need the size, in pixels, of each map tile image. This means that the size of the map, in pixels, is given by: <em>2<sup>zoomLevel</sup> * tileSize</em>.</p><p>The code to <em>project</em> a geographical point on to the screen is shown below:</p><pre class="csharp" name="code">public Point GeoToScreen(Point geographicalPoint, int zoomLevel, int tileSize) {<br/>    // Convert to normalized mercator<br/>    double lon = geographicalPoint.X;<br/>    double lat = geographicalPoint.Y;<br/>    if (lon &gt; 180) {<br/>        lon -= 360;<br/>    }<br/>    lon /= 360;<br/>    lon += 0.5;<br/>    lat = 0.5 - ((Math.Log(Math.Tan((Math.PI / 4) + <br/>                 ((0.5 * Math.PI * lat) / 180))) / Math.PI) / 2.0);<br/>    double scale = (1 &lt;&lt; zoomLevel) * tileSize;<br/>    return new Point(lon * scale, lat * scale);<br/>}</pre><p>This code first normalizes the longitude (X direction) so that it is in the range 0.0 to 1.0 (where 0.0 is the left of the map and 1.0 is the right). Then it does what I like to call "mathy stuff" (the calculations are taken from <a href="http://mapki.com/wiki/Tile_utility_code_in_Java">similar code written in Java</a>) with the latitude to put it in the same range (0.0 is the top, 1.0 is the bottom). Finally, we calculate the scale of the map (height/width in pixels, since the map is technically a square) and then we can use the normalized longitude and latitude as ratios of that scale.</p><p>The ScreenToGeo method is similar, the code is below. I won't describe this, but just provide it for reference.</p><pre class="csharp" name="code">public Point ScreenToGeo(Point screenPoint, int zoomLevel, int tileSize) {<br/>    int pixelSpan = (1 &lt;&lt; zoomLevel) * tileSize;<br/>    double lngWidth = 360.0 / pixelSpan; // width in degrees longitude<br/>    double lng = -180 + (screenPoint.X * lngWidth); // left edge in degrees longitude<br/>    double latHeightMerc = 1.0 / pixelSpan; // height in &quot;normalized&quot; mercator 0,0 top left<br/>    double latMerc = screenPoint.Y * latHeightMerc; // top edge in &quot;normalized&quot; mercator 0,0 top left<br/>    <br/>    // convert top and bottom lat in mercator to degrees<br/>    // note that in fact the coordinates go from about -85 to +85 not -90 to 90!<br/>    double lat = (180 / Math.PI) * ((2 * Math.Atan(Math.Exp(Math.PI * (1 - (2 * latMerc)))))<br/>                       - (Math.PI / 2));<br/>    return new Point(lng, lat);<br/>}</pre><p>By the way, feel free to use any of the code in this post in your own application. Consider it &quot;Public Domain&quot;. However, I would appreciate (but not require) if you would place a comment near it indicating that this blog is the source of the original code.</p><p>Hopefully this helps those of you writing mapping applications in C#! Please post any questions or comments in the comments section!</p>
