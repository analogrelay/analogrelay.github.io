---
disqus_old: true
layout: post
title: "Using the Razor parser outside of ASP.Net"
description: ""
category:
tags: []
permalink: /blog/2010/7/22/using-the-razor-parser-outside-of-aspnet.html
---
<p>When Scott Guthrie originally blogged about Razor, he mentioned that it was fully hostable outside of ASP.Net.&nbsp; The engine itself is not quite as detached from System.Web as we'd like, but it's close and we're going to get it way closer in the next release.</p>  <p>Having said that, you can still host Razor outside of the ASP.Net pipeline with the current beta! It's a little trickier, and you do technically need to reference System.Web.&nbsp; I've written a sample console app that I'm attaching to this post called "rzrc" which takes in&nbsp; a .cshtml or .vbhtml Razor file and runs it through the parser and code generator to produce a .cs or .vb file.&nbsp; I'll walk through the main logic here and go over what each section does.</p>  <p>However, I was not the first to do this! Full credit for that goes to <a href="http://thegsharp.wordpress.com/">Gustavo Machado</a>, who wrote <a href="http://thegsharp.wordpress.com/2010/07/07/using-razor-from-a-console-application/">an excellent post</a> in which he used Reflector to work out how to run the Razor parser and code generator.&nbsp; Well done Gustavo!&nbsp; There are a few things that this version does that Gustavo's doesn't, such as cleaning up the Web-related stuff in the generated code and selecting the language based on the Code Language, but he basically hit it spot on!</p>  <p>The first thing my console app does is get the input file name, extract the extension and look up what Razor Code Language it uses.&nbsp; This is done using the CodeLanguageService class, which is part of the Razor APIs:</p>  <pre class="csharp" name="code">CodeLanguageService languageService = CodeLanguageService.GetServiceByExtension(extension);<br/>if (languageService == null) {<br/>    Console.WriteLine("{0} is not a Razor code language", extension);<br/>    return;<br/>}</pre><br/><br/><p>Then, we fire up the parser and the code generator.&nbsp; A CodeLanguageService is basically a factory for constructing a Code Parser, to parse the code blocks after an "@" and a matching Code Generator to write the final C# or VB class.</p><br/><br/><pre class="csharp" name="code">InlinePageParser parser = new InlinePageParser(languageService.CreateCodeParser(), new HtmlMarkupParser());<br/>CodeGenerator codeGenerator = <br/>    languageService.CreateCodeGeneratorParserListener(className,<br/>                                                        rootNamespaceName: "Template", <br/>                                                        applicationTypeName: "object", <br/>                                                        inputFileName, <br/>                                                        baseClass: "System.Object");</pre><br/><br/><p>When you run the Razor Parser, you must provide it with an object implementing IParserConsumer.&nbsp; This interface has callbacks which the parser will call when it encounters various Razor constructs (more details on the Razor parse tree later).&nbsp; CodeGenerator implements this interface and responds to the these callbacks by generating code.&nbsp; However, it does nothing with the errors, so in the console app, I've written a very simple IParserConsumer called CustomParserConsumer which wraps the code generator and outputs errors to the console.&nbsp; I won't put the code here, but it's in the sample, so take a look there if you're interested.</p><br/><br/><p>Now that we've got all the objects we need, we can actually run the parser over the input</p><br/><br/><pre class="csharp" name="code">CustomParserConsumer consumer = new CustomParserConsumer() { CodeGenerator = codeGenerator };<br/>using (StreamReader reader = new StreamReader(inputFileName)) {<br/>    parser.Parse(reader, consumer);<br/>}</pre><br/><br/><p>Once Parse returns, the Code Generator will have built a CodeDOM tree representing the generated code during the callbacks, so we know that our code is ready to go.&nbsp; Right now, the Code Generator adds in some web specific things.&nbsp; For example, when we constructed the Code Gneerator above, we gave it an "applicationTypeName" which (in a web context) is the type name of the class defined in Global.asax, if there is one.&nbsp; Since we are trying to generate a template that isn't related to the web, we can get the CodeDOM tree from the Code Generator and remove these things.</p><br/><br/><pre class="csharp" name="code">codeGenerator.GeneratedCode.Namespaces[0].Types[0].Members.RemoveAt(0);<br/>codeGenerator.GeneratedCode.Namespaces[0].Types[0].BaseTypes.Clear();<br/>codeGenerator.GeneratedCode.Namespaces[0].Imports.Clear();</pre><br/><br/><p>Finally, we use the CodeDOM to write the code to a C# or VB class file (provider is a CodeDomProvider from System.CodeDom.Compiler):</p><br/><br/><pre class="csharp" name="code">using (StreamWriter writer = new StreamWriter(outputFile)) {<br/>    provider.GenerateCodeFromCompileUnit(codeGenerator.GeneratedCode, writer, new CodeDom.CodeGeneratorOptions());<br/>}</pre><br/><br/><p>And we're done!&nbsp; This is definitely more complicated than we'd like, but there are plans to simplify this API significantly in future releases.&nbsp; For the most part, all we've done is left the methods our ASP.Net Build Provider uses open and accessible.&nbsp; I wouldn't bet on these APIs staying around too long, but any API changes from here on should be simplifications.&nbsp; For now though, check out the sample I've attached and play around!&nbsp; Note that you must have WebMatrix installed to use the sample.&nbsp; </p><br/><br/><p>I've put some comments in which start with "EXT" which contain tips on how to extend this code to your own use.&nbsp; Please feel free to take this code and use it absolutely anywhere you want!&nbsp; Let me know how your using Razor by either tweeting me at @anurse or email me at andrew AT andrewnurse DOT net.</p><br/><br/><p>Download the console app here: <a href="https://s3.amazonaws.com/vibrantcode-res/blogcontent/imported/rzrc.zip">rzrc.zip (3.46 KB)</a></p>
