---
disqus_old: true
layout: post
title: "Inside Razor - Part 2 - Expressions"
description: ""
category:
tags: []
permalink: /blog/2010/7/12/inside-razor-part-2-expressions.html
---
<p>This is part 2 of my Inside Razor series. Read Part 1 <a href="/2010/07/05/InsideRazorNdashPart1NdashRecursivePingPong.aspx">here</a>.</p>  <p>In my previous post, I glossed over one line in my sample:</p>  <pre class="csharp" name="code">&lt;li&gt;@p.Name ($@p.Price)&lt;/li&gt;</pre><p>Well, it's finally time to get in to how this is parsed! So, to recap from last time, when we see the "&lt;li&gt;" here, we know that we are parsing a block of markup which ends at the "&lt;/li&gt;". The markup parser scans forward until it finds the end tag, but before it reaches it, it sees an "@". So, just as with "@foreach", it switches to the code parser.</p><p>This is where things get a bit different. The C# code parser looks at that first identifier: "p" and checks its internal list of C# keywords. Of course, "p" is not a C# keyword, so the C# code parser enters "Implicit Expression" mode. The algorithm for parsing implicit expressions is something like the following:</p><ol><li>First, <strong><em>Read </em></strong>an identifier </li><li>Is the next character a "(" or "["?<ul><li>Yes - <strong><em>Read</em></strong> to the matching ")" or "]", then <strong><em>Go To</em> </strong>2 </li><li>No - <strong><em>Continue</em></strong> to 3 </li></ul></li><li>Is the next character a "."?    <ul><li>Yes - <strong><em>Continue</em></strong> to 4 </li><li>No - <strong><em>End</em></strong> of Expression </li></ul></li><li>Is the character AFTER the "." a valid start character for a C# identifier?<ul><li>Yes - <strong><em>Read</em> </strong>the "." and <strong><em>Go To</em> </strong>1 </li><li>No - <u>DO NOT Read</u> the ".", and <em><strong>End</strong></em> the Expression </li></ul></li></ol><p>The high-level overview of this algorithm is that an implicit expression is an identifier, followed by any number of method calls ("()"), indexing expressions ("[]") and member access expressions ("."). And, whitespace is <strong>not allowed</strong> (except for within "()" or "[]"). So for example, these are all valid implicit expressions in Razor:</p><pre class="csharp" name="code">@p.Name<br/>@p.Name.ToString()<br/>@p.Name.ToString()[6 - 2]<br/>@p.Name.Replace("ASPX", "Razor")[i++]</pre><p>However, the following are not valid, and the second section (after the arrow, "==&gt;") is the only part that would be considered part of the expression by Razor:</p><pre class="csharp" name="code">@1 + 1 ==&gt; @<br/>@p++ ==&gt; @p<br/>@p    .   Name ==&gt; @p<br/>@p.Name.Length - 1 ==&gt; @p.Name.Length</pre><p>This is why we have another syntax for expressions: "@(...)". This syntax allows anything you want within the "()". So, you can write all of the previous examples using that syntax as an escape-hatch:</p><pre class="csharp" name="code">@(1 + 1) <br/>@(p++) <br/>@(p    .   Name) <br/>@(p.Name.Length - 1)</pre><p>Once we've identified the expression, we pass it along to our code generator. When generating the code for "@foreach () { ... }", we just dump that code into the generated C# class as-is, but when we identify an expression (either implicit or explicit) we do something a little different. You probably noticed that unlike ASPX, there is only one control construct: "@", there is no "@=" to distinguish code that we run vs. expressions that we render the value of. This is where some of the magic of Razor comes in. If we see "@foreach" for example, we know that "foreach" is a C# keyword, so that block is written as a statement to be executed. When we see "@p.Name" or "@(1 + 1)", we know that they are expressions, so after executing them, we render the result. So basically:</p><ul><li>@if, @switch, @try, @foreach, @for, etc. are equivalent to "&lt;% %&gt;" </li><li>@p.Name, @(p++), @(1 + 1), etc. are equivalent to "&lt;%: %&gt;" </li></ul><p>Another side note is that expressions are equivalent to "&lt;%:" and <strong>NOT </strong>"&lt;%=". We made a decision in Razor that <strong>HTML encoding should be the default</strong>, and that if you want to write unencoded strings, you can use the IHtmlString interface that has been <a href="http://haacked.com/archive/2009/09/25/html-encoding-code-nuggets.aspx">blogged about</a> before.</p><p>So, with all that background, we can quickly jump back to our initial sample:</p><pre class="csharp" name="code">&lt;li&gt;@p.Name ($@p.Price)&lt;/li&gt;</pre><p>When we see "@p.Name" we identify that as an expression, but the space before the "(" stops us from interpreting it as a method call. Then " ($" are all markup and when we see the "@", we interpret "@p.Price" as an expression and stop at the ")".</p><p>So there's a quick overview of how Razor identifies and parses expressions. In my next post I'm going to discuss hosting the Razor parser outside of ASP.Net. As before, please feel free to leave comments if you have questions, or send me a tweet (@anurse) or an email (andrew AT andrewnurse DOT net).</p>
