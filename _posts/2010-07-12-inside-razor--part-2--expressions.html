---
layout: post
title: "Inside Razor - Part 2 - Expressions"
description: ""
category:
tags: []
permalink: /blog/2010/7/12/inside-razor-part-2-expressions.html
---
<p>This is part 2 of my Inside Razor series.&#160; Read Part 1 <a href="/2010/07/05/InsideRazorNdashPart1NdashRecursivePingPong.aspx">here</a>.</p>  <p>In my previous post, I glossed over one line in my sample:</p>  <pre class="csharp" name="code">&lt;li&gt;@p.Name ($@p.Price)&lt;/li&gt;</pre><br/><br/><p>Well, it's finally time to get in to how this is parsed!&#160; So, to recap from last time, when we see the "&lt;li&gt;" here, we know that we are parsing a block of markup which ends at the "&lt;/li&gt;"?.&#160; The markup parser scans forward until it finds the end tag, but before it reaches it, it sees an "@"?.&#160; So, just as with "@foreach"?, it switches to the code parser.</p><br/><br/><p>This is where things get a bit different.&#160; The C# code parser looks at that first identifier: "p" and checks its internal list of C# keywords.&#160; Of course, "p" is not a C# keyword, so the C# code parser enters "Implicit Expression" mode.&#160; The algorithm for parsing implicit expressions is something like the following:</p><br/><br/><ol><br/>  <li>First, <strong><em>Read </em></strong>an identifier </li><br/><br/>  <li>Is the next character a "(" or "["? <br/>    <ul><br/>      <li>Yes - <strong><em>Read</em></strong> to the matching ")" or '"?]"?, then <strong><em>Go To</em> </strong>2 </li><br/><br/>      <li>No - <strong><em>Continue</em></strong> to 3 </li><br/>    </ul><br/>  </li><br/><br/>  <li>Is the next character a "."?? <br/>    <ul><br/>      <li>Yes - <strong><em>Continue</em></strong> to 4 </li><br/><br/>      <li>No - <strong><em>End</em></strong> of Expression </li><br/>    </ul><br/>  </li><br/><br/>  <li>Is the character AFTER the "." a valid start character for a C# identifier? <br/>    <ul><br/>      <li>Yes - <strong><em>Read</em> </strong>the "." and <strong><em>Go To</em> </strong>1 </li><br/><br/>      <li>No - <u>DO NOT Read</u> the "."?, and <em><strong>End</strong></em> the Expression </li><br/>    </ul><br/>  </li><br/></ol><br/><br/><p>The high-level overview of this algorithm is that an implicit expression is an identifier, followed by any number of method calls ("()"?), indexing expressions ("[]"?) and member access expressions ("."?).&#160; And, whitespace is <strong>not allowed</strong> (except for within "()" or "[]"?).&#160; So for example, these are all valid implicit expressions in Razor:</p><br/><br/><pre class="csharp" name="code">@p.Name<br/>@p.Name.ToString()<br/>@p.Name.ToString()[6 - 2]<br/>@p.Name.Replace("ASPX"?, "Razor"?)[i++]</pre><br/><br/><p>However, the following are not valid, and the second section (after the arrow, "==&gt;"?) is the only part that would be considered part of the expression by Razor:</p><br/><br/><pre class="csharp" name="code">@1 + 1 ==&gt; @<br/>@p++ ==&gt; @p<br/>@p    .   Name ==&gt; @p<br/>@p.Name.Length - 1 ==&gt; @p.Name.Length</pre><br/><br/><p>This is why we have another syntax for expressions: "@(...)"?.&#160; This syntax allows anything you want within the "()"?.&#160; So, you can write all of the previous examples using that syntax as an escape-hatch:</p><br/><br/><pre class="csharp" name="code">@(1 + 1) <br/>@(p++) <br/>@(p    .   Name) <br/>@(p.Name.Length - 1)</pre><br/><br/><p>Once we've identified the expression, we pass it along to our code generator.&#160; When generating the code for "@foreach () { ... }"?, we just dump that code into the generated C# class as-is, but when we identify an expression (either implicit or explicit) we do something a little different.&#160; You probably noticed that unlike ASPX, there is only one control construct: "@"?, there is no "@=" to distinguish code that we run vs. expressions that we render the value of.&#160; This is where some of the magic of Razor comes in.&#160; If we see "@foreach" for example, we know that "foreach" is a C# keyword, so that block is written as a statement to be executed.&#160; When we see "@p.Name" or "@(1 + 1)"?, we know that they are expressions, so after executing them, we render the result.&#160; So basically:</p><br/><br/><ul><br/>  <li>@if, @switch, @try, @foreach, @for, etc. are equivalent to "&lt;% %&gt;" </li><br/><br/>  <li>@p.Name, @(p++), @(1 + 1), etc. are equivalent to "&lt;%: %&gt;" </li><br/></ul><br/><br/><p>Another side note is that expressions are equivalent to "&lt;%:" and <strong>NOT </strong>"&lt;%="?.&#160; We made a decision in Razor that <strong>HTML encoding should be the default</strong>, and that if you want to write unencoded strings, you can use the IHtmlString interface that has been <a href="http://haacked.com/archive/2009/09/25/html-encoding-code-nuggets.aspx">blogged about</a> before.</p><br/><br/><p>So, with all that background, we can quickly jump back to our initial sample:</p><br/><br/><pre class="csharp" name="code">&lt;li&gt;@p.Name ($@p.Price)&lt;/li&gt;</pre><br/><br/><p>When we see "@p.Name" we identify that as an expression, but the space before the "(" stops us from interpreting it as a method call.&#160; Then " ($" are all markup and when we see the "@"?, we interpret "@p.Price" as an expression and stop at the ")"?.</p><br/><br/><p>So there's a quick overview of how Razor identifies and parses expressions.&#160; In my next post I'm going to discuss hosting the Razor parser outside of ASP.Net.&#160; As before, please feel free to leave comments if you have questions, or send me a tweet (@anurse) or an email (andrew AT andrewnurse DOT net).</p>
